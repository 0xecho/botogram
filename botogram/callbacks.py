# Copyright (c) 2015-2017 The Botogram Authors (see AUTHORS)
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
#   The above copyright notice and this permission notice shall be included in
#   all copies or substantial portions of the Software.
#
#   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER


class ButtonsRow:
    """A row of an inline keyboard"""

    def __init__(self):
        self._content = []

    def url(self, label, url):
        """Open an URL when the button is pressed"""
        self._content.append({"text": label, "url": url})

    def callback(self, label, callback, data=None):
        """Trigger a callback when the button is pressed"""
        if data is not None:
            msg = "%s\0%s" % (callback, data)
        else:
            msg = callback

        self._content.append({"text": label, "callback_data": msg})

    def switch_inline_query(self, label, query="", current_chat=False):
        """Switch the user to this bot's inline query"""
        if current_chat:
            self._content.append({
                "text": label,
                "switch_inline_query_current_chat": query,
            })
        else:
            self._content.append({
                "text": label,
                "switch_inline_query": query,
            })


class Buttons:
    """Factory for inline keyboards"""

    def __init__(self):
        self._rows = {}

    def __getitem__(self, index):
        if index not in self._rows:
            self._rows[index] = ButtonsRow()
        return self._rows[index]

    def _serialize_attachment(self):
        rows = [
            row._content for i, row in sorted(
                tuple(self._rows.items()), key=lambda i: i[0]
            )
        ]

        return {"inline_keyboard": rows}


def buttons():
    """Create a new inline keyboard"""
    return Buttons()


def parse_callback_data(data):
    """Parse the callback data generated by botogram and return it"""
    if "\0" in data:
        name, custom = data.split("\0", 1)
        return name, custom
    else:
        return data, None


def process(bot, chains, update):
    """Process a callback sent to the bot"""
    for hook in chains["callbacks"]:
        bot.logger.debug("Processing update #%s with the hook %s" %
                         (update.update_id, hook.name))

        result = hook.call(bot, update)
        if result is True:
            bot.logger.debug("Update #%s was just processed by the %s hook" %
                             (update.update_id, hook.name))
            return

    bot.logger.debug("No hook actually processed the #%s update." %
                     update.update_id)
